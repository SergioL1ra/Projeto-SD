$date
	Sun Apr 13 14:17:27 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_mips $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$scope module mp $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # zero $end
$var wire 5 $ write_reg [4:0] $end
$var wire 32 % write_data [31:0] $end
$var wire 32 & sign_immediate [31:0] $end
$var wire 32 ' result [31:0] $end
$var wire 1 ( reg_write $end
$var wire 1 ) reg_dst $end
$var wire 32 * read_data [31:0] $end
$var wire 1 + pc_src $end
$var wire 32 , pc_plus4 [31:0] $end
$var wire 32 - pc_out [31:0] $end
$var wire 32 . pc_next [31:0] $end
$var wire 32 / pc_branch [31:0] $end
$var wire 1 0 mem_write $end
$var wire 1 1 mem_to_reg $end
$var wire 1 2 jump $end
$var wire 32 3 instruction [31:0] $end
$var wire 32 4 input2 [31:0] $end
$var wire 32 5 input1 [31:0] $end
$var wire 32 6 branch_address [31:0] $end
$var wire 1 7 branch $end
$var wire 1 8 alu_src $end
$var wire 32 9 alu_result [31:0] $end
$var wire 4 : alu_control [3:0] $end
$scope module alu $end
$var wire 1 # zero $end
$var wire 32 ; input2 [31:0] $end
$var wire 32 < input1 [31:0] $end
$var wire 4 = alu_control [3:0] $end
$var reg 32 > alu_result [31:0] $end
$upscope $end
$scope module ba $end
$var wire 32 ? y [31:0] $end
$var wire 32 @ b [31:0] $end
$var wire 32 A a [31:0] $end
$upscope $end
$scope module cou $end
$var wire 6 B funct [5:0] $end
$var wire 6 C op [5:0] $end
$var wire 1 + pc_src $end
$var wire 1 # zero $end
$var wire 1 ( reg_write $end
$var wire 1 ) reg_dst $end
$var wire 1 0 mem_write $end
$var wire 1 1 mem_to_reg $end
$var wire 1 2 jump $end
$var wire 1 7 branch $end
$var wire 1 8 alu_src $end
$var wire 2 D alu_op [1:0] $end
$var wire 4 E alu_control [3:0] $end
$scope module ad $end
$var wire 6 F funct [5:0] $end
$var wire 2 G alu_op [1:0] $end
$var reg 4 H alu_control [3:0] $end
$upscope $end
$scope module md $end
$var wire 6 I op [5:0] $end
$var reg 2 J alu_op [1:0] $end
$var reg 1 8 alu_src $end
$var reg 1 7 branch $end
$var reg 1 2 jump $end
$var reg 1 1 mem_to_reg $end
$var reg 1 0 mem_write $end
$var reg 1 ) reg_dst $end
$var reg 1 ( reg_write $end
$upscope $end
$upscope $end
$scope module dm $end
$var wire 32 K address [31:0] $end
$var wire 1 ! clk $end
$var wire 1 0 we $end
$var wire 32 L write_data [31:0] $end
$var reg 32 M read_data [31:0] $end
$scope begin $unm_blk_37 $end
$var integer 32 N i [31:0] $end
$upscope $end
$upscope $end
$scope module im $end
$var wire 32 O PC [31:0] $end
$var reg 32 P instruction [31:0] $end
$upscope $end
$scope module mc $end
$var wire 32 Q in1 [31:0] $end
$var wire 1 + sel $end
$var wire 32 R out [31:0] $end
$var wire 32 S in0 [31:0] $end
$upscope $end
$scope module mr $end
$var wire 32 T in0 [31:0] $end
$var wire 32 U in1 [31:0] $end
$var wire 1 1 sel $end
$var wire 32 V out [31:0] $end
$upscope $end
$scope module ms $end
$var wire 1 8 sel $end
$var wire 32 W out [31:0] $end
$var wire 32 X in1 [31:0] $end
$var wire 32 Y in0 [31:0] $end
$upscope $end
$scope module mw $end
$var wire 5 Z in0 [4:0] $end
$var wire 5 [ in1 [4:0] $end
$var wire 1 ) sel $end
$var wire 5 \ out [4:0] $end
$upscope $end
$scope module pa $end
$var wire 32 ] b [31:0] $end
$var wire 32 ^ y [31:0] $end
$var wire 32 _ a [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 32 ` pc_in [31:0] $end
$var wire 32 a pc_out [31:0] $end
$var wire 1 " reset $end
$var reg 32 b data [31:0] $end
$upscope $end
$scope module rf $end
$var wire 1 ! clk $end
$var wire 5 c ra1 [4:0] $end
$var wire 5 d ra2 [4:0] $end
$var wire 5 e wa3 [4:0] $end
$var wire 32 f wd3 [31:0] $end
$var wire 1 ( we3 $end
$var reg 32 g rd1 [31:0] $end
$var reg 32 h rd2 [31:0] $end
$scope begin $unm_blk_31 $end
$var integer 32 i i [31:0] $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 j a [15:0] $end
$var wire 32 k y [31:0] $end
$upscope $end
$scope module sl $end
$var wire 32 l a [31:0] $end
$var reg 32 m y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b100011000 m
b1000110 l
b1000110 k
b1000110 j
b100000 i
b0 h
b0 g
b1000110 f
b1000 e
b1000 d
b0 c
b0 b
b0 a
b100 `
b0 _
b100 ^
b100 ]
b1000 \
b0 [
b1000 Z
b0 Y
b1000110 X
b1000110 W
b1000110 V
b0 U
b1000110 T
b100 S
b100 R
b100011100 Q
b100000000010000000000001000110 P
b0 O
b1000000 N
b0 M
b0 L
b1000110 K
b0 J
b1000 I
b10 H
b0 G
b110 F
b10 E
b0 D
b1000 C
b110 B
b100011000 A
b100 @
b100011100 ?
b1000110 >
b10 =
b0 <
b1000110 ;
b10 :
b1000110 9
18
07
b100011000 6
b0 5
b1000110 4
b100000000010000000000001000110 3
02
01
00
b100011100 /
b100 .
b0 -
b100 ,
0+
b0 *
0)
1(
b1000110 '
b1000110 &
b0 %
b1000 $
0#
1"
0!
$end
#5
b1000110 %
b1000110 L
b1000110 Y
b1000110 h
1!
#10
0!
0"
#15
b1000 '
b1000 V
b1000 f
b1000 9
b1000 >
b1000 K
b1000 T
b1000 4
b1000 ;
b1000 W
b100000 6
b100000 A
b100000 m
10
0(
b1000 &
b1000 X
b1000 k
b1000 l
b1000 j
b1000 B
b1000 F
b101011 C
b101011 I
b1000 .
b1000 R
b1000 `
b10101100000010000000000000001000 3
b10101100000010000000000000001000 P
b101000 /
b101000 ?
b101000 Q
b1000 ,
b1000 @
b1000 S
b1000 ^
b100 -
b100 O
b100 _
b100 a
b100 b
1!
#20
0!
#25
b111100 '
b111100 V
b111100 f
b111100 9
b111100 >
b111100 K
b111100 T
b1001 $
b1001 \
b1001 e
b111100 4
b111100 ;
b111100 W
b11110000 6
b11110000 A
b11110000 m
b0 %
b0 L
b0 Y
b0 h
00
1(
b1001 Z
b111100 &
b111100 X
b111100 k
b111100 l
b111100 j
b1001 d
b111100 B
b111100 F
b1000 C
b1000 I
b0 *
b0 M
b0 U
b1100 .
b1100 R
b1100 `
b100000000010010000000000111100 3
b100000000010010000000000111100 P
b11111100 /
b11111100 ?
b11111100 Q
b1100 ,
b1100 @
b1100 S
b1100 ^
b1000 -
b1000 O
b1000 _
b1000 a
b1000 b
1!
#30
0!
#35
b1001 '
b1001 V
b1001 f
b1001 9
b1001 >
b1001 K
b1001 T
b1001 4
b1001 ;
b1001 W
b100100 6
b100100 A
b100100 m
10
0(
b1001 &
b1001 X
b1001 k
b1001 l
b1001 j
b1001 B
b1001 F
b101011 C
b101011 I
b111100 %
b111100 L
b111100 Y
b111100 h
b10000 .
b10000 R
b10000 `
b10101100000010010000000000001001 3
b10101100000010010000000000001001 P
b110100 /
b110100 ?
b110100 Q
b10000 ,
b10000 @
b10000 S
b10000 ^
b1100 -
b1100 O
b1100 _
b1100 a
b1100 b
1!
#40
0!
#45
b1010 '
b1010 V
b1010 f
b1010 9
b1010 >
b1010 K
b1010 T
b1010 $
b1010 \
b1010 e
b111100 4
b111100 ;
b111100 W
b10100000010001000 6
b10100000010001000 A
b10100000010001000 m
b1000110 5
b1000110 <
b1000110 g
b110 :
b110 =
b110 E
b110 H
b10 D
b10 G
b10 J
00
08
1)
1(
b1010 [
b101000000100010 &
b101000000100010 X
b101000000100010 k
b101000000100010 l
b101000000100010 j
b1000 c
b100010 B
b100010 F
b0 C
b0 I
b0 *
b0 M
b0 U
b10100 .
b10100 R
b10100 `
b1000010010101000000100010 3
b1000010010101000000100010 P
b10100000010011100 /
b10100000010011100 ?
b10100000010011100 Q
b10100 ,
b10100 @
b10100 S
b10100 ^
b10000 -
b10000 O
b10000 _
b10000 a
b10000 b
1!
#50
0!
#55
b1010 4
b1010 ;
b1010 W
b101000 6
b101000 A
b101000 m
b1010 %
b1010 L
b1010 Y
b1010 h
b0 5
b0 <
b0 g
b10 :
b10 =
b10 E
b10 H
b0 D
b0 G
b0 J
10
18
0)
0(
b0 [
b1010 Z
b1010 &
b1010 X
b1010 k
b1010 l
b1010 j
b1010 d
b0 c
b1010 B
b1010 F
b101011 C
b101011 I
b11000 .
b11000 R
b11000 `
b10101100000010100000000000001010 3
b10101100000010100000000000001010 P
b1000000 /
b1000000 ?
b1000000 Q
b11000 ,
b11000 @
b11000 S
b11000 ^
b10100 -
b10100 O
b10100 _
b10100 a
b10100 b
1!
#60
0!
#65
x+
bx '
bx V
bx f
x#
bx 9
bx >
bx K
bx T
bx $
bx \
bx e
bx 4
bx ;
bx W
bx00 6
bx00 A
bx00 m
bx %
bx L
bx Y
bx h
bx 5
bx <
bx g
b0 :
b0 =
b0 E
b0 H
bx D
bx G
bx J
x2
x1
x0
x7
x8
x)
x(
bx [
bx Z
bx &
bx X
bx k
bx l
bx j
bx d
bx c
bx B
bx F
bx C
bx I
bx *
bx M
bx U
bx .
bx R
bx `
bx 3
bx P
bx /
bx ?
bx Q
b11100 ,
b11100 @
b11100 S
b11100 ^
b11000 -
b11000 O
b11000 _
b11000 a
b11000 b
1!
#70
0!
#75
bx ,
bx @
bx S
bx ^
bx -
bx O
bx _
bx a
bx b
1!
#80
0!
#85
1!
#90
0!
#95
1!
#100
0!
#105
1!
#110
0!
